#pragma kernel Init
#pragma kernel HorizontalIFFT
#pragma kernel VerticalIFFT
#pragma kernel Permute

static const float PI = 3.1415926;

RWTexture2D<float4> PrecomputeBuffer;
int N;

float2 ComplexMult(float2 a, float2 b)
{
    return float2(a.r * b.r - a.g * b.g, a.r * b.g + a.g * b.r);
}
float2 ComplexExp(float2 a)
{
    return float2(cos(a.y), sin(a.y)) * exp(a.x);
}

// 预计算蝴蝶运算的权重和下标
[numthreads(1, 8, 1)]
void Init(uint3 id : SV_DispatchThreadID)
{
    uint b = N >> (id.x + 1); // 第b层蝶形运算
    float2 mult = 2 * PI * float2(0, 1) / N;
    uint i = (2 * b * (id.y / b) + id.y % b) % N; // 蝶形输入
    float2 twiddle = ComplexExp(-mult * (uint(id.y / b) * b)); // 旋转因子
    PrecomputeBuffer[id.xy] = float4(twiddle.x, twiddle.y, i, i + b);
    PrecomputeBuffer[uint2(id.x, id.y + uint(N) / 2)] = float4(-twiddle.x, -twiddle.y, i, i + b);
}

uint Step;
bool PingPong;
RWTexture2D<float2> Buffer0;
RWTexture2D<float2> Buffer1;

[numthreads(8, 8, 1)]
void HorizontalIFFT(uint3 id : SV_DispatchThreadID)
{
    float4 data = PrecomputeBuffer[uint2(Step, id.x)];
    uint2 indices = (uint2)data.ba;
    if (PingPong)
    {
        Buffer1[id.xy] = Buffer0[uint2(indices.x, id.y)] + ComplexMult(float2(data.r, -data.g), Buffer0[uint2(indices.y, id.y)]);
    }
    else
    {
        Buffer0[id.xy] = Buffer1[uint2(indices.x, id.y)] + ComplexMult(float2(data.r, -data.g), Buffer1[uint2(indices.y, id.y)]);
    }
}

[numthreads(8, 8, 1)]
void VerticalIFFT(uint3 id : SV_DispatchThreadID)
{
    float4 data = PrecomputeBuffer[uint2(Step, id.y)];
    uint2 indices = uint2(data.zw);
    if (PingPong)
    {
        Buffer1[id.xy] = Buffer0[uint2(id.x, indices.x)] + ComplexMult(float2(data.x, -data.y), Buffer0[uint2(id.x, indices.y)]);
    }
    else
    {
        Buffer0[id.xy] = Buffer1[uint2(id.x, indices.x)] + ComplexMult(float2(data.x, -data.y), Buffer1[uint2(id.x, indices.y)]);
    }
}

[numthreads(8, 8, 1)]
void Permute(uint3 id : SV_DispatchThreadID)
{
    Buffer0[id.xy] = Buffer0[id.xy] * (1.0 - 2.0 * ((id.x + id.y) % 2));
}